Plug 'neovim/nvim-lspconfig'

function! SetupLsp()
  lua << EOF
local lspconfig = require('lspconfig')

-- Enable LSP log level trace (helps for debugging)
vim.lsp.set_log_level('trace')

-- Global state variables
_G.lsp_log_buf = nil
_G.lsp_log_win = nil
_G.lsp_log_timer = nil
_G.lsp_log_offset = nil

-- Function to toggle the LSP log panel
_G.toggle_lsp_log = function()
  local lsp_log_path = vim.lsp.get_log_path()
  local buf_name = "LSP Log Viewer"

  -- If window is open, close it
  if _G.lsp_log_win and vim.api.nvim_win_is_valid(_G.lsp_log_win) then
    vim.api.nvim_win_close(_G.lsp_log_win, true)
    _G.lsp_log_win = nil
    if _G.lsp_log_timer then
      _G.lsp_log_timer:stop()
      _G.lsp_log_timer = nil
    end
    return
  end

  -- Function to create or retrieve the log buffer
  local function get_or_create_log_buffer()
    if _G.lsp_log_buf and vim.api.nvim_buf_is_valid(_G.lsp_log_buf) then
      return _G.lsp_log_buf
    end
    local buf = vim.api.nvim_create_buf(false, true) -- Create a new unlisted buffer
    vim.api.nvim_buf_set_name(buf, buf_name) -- Name the buffer
    vim.api.nvim_buf_set_option(buf, "bufhidden", "wipe") -- Auto-wipe buffer on close
    vim.api.nvim_buf_set_option(buf, "buftype", "nofile") -- Prevent writing to disk
    vim.api.nvim_buf_set_option(buf, "modifiable", true) -- Allow editing
    _G.lsp_log_buf = buf
    return buf
  end

  -- Open the buffer in a vsplit
  local buf = get_or_create_log_buffer()
  vim.api.nvim_command("vsplit")
  local win = vim.api.nvim_get_current_win()
  vim.api.nvim_win_set_buf(win, buf)
  _G.lsp_log_win = win

  -- Function to read new log entries
  local function start_tailing_log()
    local fd = vim.loop.fs_open(lsp_log_path, "r", 438)
    if not fd then
      vim.api.nvim_err_writeln("Unable to open LSP log file: " .. lsp_log_path)
      return
    end

    -- Start from the end if offset is nil
    if _G.lsp_log_offset == nil then
      local stat = vim.loop.fs_fstat(fd)
      _G.lsp_log_offset = stat and stat.size or 0
    end

    -- Function to append new lines
    local function check_for_updates()
      vim.loop.fs_read(fd, 4096, _G.lsp_log_offset, function(err, chunk)
        if err then
          vim.api.nvim_err_writeln("Error reading LSP log file: " .. err)
          return
        end
        if chunk then
          _G.lsp_log_offset = _G.lsp_log_offset + #chunk
          vim.schedule(function()
            local lines = vim.split(chunk, "\n", { trimempty = true })
            if #lines > 0 and vim.api.nvim_buf_is_valid(buf) then
              -- Insert new logs at the top (reverse order)
              local existing_lines = vim.api.nvim_buf_get_lines(buf, 0, -1, false)
              for i = #lines, 1, -1 do
                table.insert(existing_lines, 1, lines[i])
              end
              vim.api.nvim_buf_set_lines(buf, 0, -1, false, existing_lines)
            end
          end)
        end
      end)
    end

    -- Run check_for_updates every second (non-blocking)
    _G.lsp_log_timer = vim.loop.new_timer()
    _G.lsp_log_timer:start(0, 1000, vim.schedule_wrap(check_for_updates))

    -- Stop the timer when Neovim exits
    vim.api.nvim_create_autocmd("VimLeavePre", {
      callback = function()
        if _G.lsp_log_timer then
          _G.lsp_log_timer:stop()
          _G.lsp_log_timer = nil
        end
        vim.loop.fs_close(fd)
      end,
    })
  end

  -- Start tailing logs
  start_tailing_log()
end

-- Setup efm-langserver
lspconfig.efm.setup {
  init_options = { documentFormatting = true },
  on_attach = function(client, bufnr)
    print("LSP attached to filetype: " .. vim.bo.filetype)
  end,
  settings = {
    languages = {
      javascript = {
        formatCommand = "eslint_d --fix-to-stdout --stdin --stdin-filename=${INPUT}",
        formatStdin = true,
        lintCommand = "eslint_d --f unix --stdin --stdin-filename=${INPUT}",
        lintStdin = true,
        lintIgnoreExitCode = true,
        lintAfterOpen = true
      },
      typescript = {
        formatCommand = "eslint_d --fix-to-stdout --stdin --stdin-filename=${INPUT}",
        formatStdin = true,
        lintCommand = "eslint_d --f unix --stdin --stdin-filename=${INPUT}",
        lintStdin = true,
        lintIgnoreExitCode = true,
        lintAfterOpen = true
      }
    }
  },
  filetypes = {
    "javascript",
    "typescript",
    "javascriptreact",
    "typescriptreact",
    "json",
    "jsonc"
  }
}

-- Keybinding to trigger formatting with <leader>l
vim.api.nvim_set_keymap('n', '<leader>l', ':lua vim.lsp.buf.format()<CR>', { noremap = true, silent = true })

-- Keybinding to toggle the LSP log panel
vim.api.nvim_set_keymap('n', '<leader>tl', ':lua _G.toggle_lsp_log()<CR>', { noremap = true, silent = true })

EOF
endfunction

autocmd VimEnter * call SetupLsp()
